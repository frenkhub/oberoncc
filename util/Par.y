-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module PargOberon where
import AbsgOberon
import LexgOberon
import ErrM

}

%name pModule Module

-- no lexer declaration
%monad { Log [Char] }
%tokentype { Token }

%token 
 '#' { PT _ (TS _ 1) }
 '&' { PT _ (TS _ 2) }
 '(' { PT _ (TS _ 3) }
 ')' { PT _ (TS _ 4) }
 '*' { PT _ (TS _ 5) }
 '+' { PT _ (TS _ 6) }
 ',' { PT _ (TS _ 7) }
 '-' { PT _ (TS _ 8) }
 '.' { PT _ (TS _ 9) }
 '/' { PT _ (TS _ 10) }
 ':' { PT _ (TS _ 11) }
 ':=' { PT _ (TS _ 12) }
 ';' { PT _ (TS _ 13) }
 '<' { PT _ (TS _ 14) }
 '<=' { PT _ (TS _ 15) }
 '=' { PT _ (TS _ 16) }
 '>' { PT _ (TS _ 17) }
 '>=' { PT _ (TS _ 18) }
 'ARRAY' { PT _ (TS _ 19) }
 'BEGIN' { PT _ (TS _ 20) }
 'BOOLEAN' { PT _ (TS _ 21) }
 'CASE' { PT _ (TS _ 22) }
 'CHAR' { PT _ (TS _ 23) }
 'CONST' { PT _ (TS _ 24) }
 'CONTINUE' { PT _ (TS _ 25) }
 'DIV' { PT _ (TS _ 26) }
 'DO' { PT _ (TS _ 27) }
 'ELSE' { PT _ (TS _ 28) }
 'ELSEIF' { PT _ (TS _ 29) }
 'END' { PT _ (TS _ 30) }
 'EXIT' { PT _ (TS _ 31) }
 'FALSE' { PT _ (TS _ 32) }
 'IF' { PT _ (TS _ 33) }
 'INTEGER' { PT _ (TS _ 34) }
 'LOOP' { PT _ (TS _ 35) }
 'MOD' { PT _ (TS _ 36) }
 'MODULE' { PT _ (TS _ 37) }
 'OF' { PT _ (TS _ 38) }
 'OR' { PT _ (TS _ 39) }
 'POINTER TO' { PT _ (TS _ 40) }
 'PROCEDURE' { PT _ (TS _ 41) }
 'REAL' { PT _ (TS _ 42) }
 'REPEAT' { PT _ (TS _ 43) }
 'RETURN' { PT _ (TS _ 44) }
 'STRING' { PT _ (TS _ 45) }
 'THEN' { PT _ (TS _ 46) }
 'TRUE' { PT _ (TS _ 47) }
 'Tvoid' { PT _ (TS _ 48) }
 'UNTIL' { PT _ (TS _ 49) }
 'VAR' { PT _ (TS _ 50) }
 'WHILE' { PT _ (TS _ 51) }
 '[' { PT _ (TS _ 52) }
 ']' { PT _ (TS _ 53) }
 '^' { PT _ (TS _ 54) }
 '|' { PT _ (TS _ 55) }
 '~' { PT _ (TS _ 56) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_quoted { PT _ (TL $$) }
L_Id { PT _ (T_Id _) }
L_err    { _ }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
String  :: { String }  : L_quoted {  $1 }
Id    :: { Id} : L_Id { Id (mkPosToken $1)}

Module :: { Module }
Module : 'MODULE' Id ';' ListDec Ini 'END' Id '.' 
	{% let
		f (Id (_, x)) = x
		lc (Id ((n, c), _)) = ":" ++ show n ++ ":" ++ show c ++ ":" 
		in if f $2 == f $7 then 
		return $ Module $2 ((reverse $4) ++ $5) $7 
		else Bad "parser" ++ (lc $2) ++
		 	"nome modulo non corrispondente. Ci si aspetta il nome \""
		 	++ (f $2) ++ "\", e non \"" ++ (f $2) ++ "\"\n."	} 


ListDec :: { [Stm] }
ListDec : {- empty -} { [] } 
  | ListDec Dec ';' { flip (:) $1 $2 }


Dec :: { Stm }
Dec : 'PROCEDURE' Id Par RetTp ';' ListDec Ini 'END' { Fun $2 $3 $4 ((reverse $6) ++ $7) } 
  | 'VAR' ListId ':' Type { Var $ map (\x -> (x, $4)) $2 }
  | 'CONST' Id '=' Exp
  	{% let
			isConst (Bin _ a b) = isConst a && isConst b
			isConst (Una "~" a) = isConst a
			isConst TRUE = True
			isConst FALSE = True
			isConst (INT _) = True
			isConst (CHAR _) = True
			isConst (STRING _) = True
			isConst (REAL _) = True
			lc (Id ((n, c), _)) = ":" ++ show n ++ ":" ++ show c ++ ":"
			f (Id (_, x)) = x
		in
			if isConst $4 then return $ Const $2 $4
			else fail "parser" ++ (lc $2) ++ 
				" espressione non costante assegnata a
				\"" ++ (f $2 ) ++ "\".\n"	}


Par :: { [(Pass, Id, Type)] }
Par : '(' ListSec ')' { foldl1 (++) $2 } 
  | {- empty -} { [] }


ListSec :: { [[(Pass, Id, Type)]] }
ListSec : Sec { (:[]) $1 } 
  | Sec ';' ListSec { (:) $1 $3 }


Sec :: { [(Pass, Id, Type)] }
Sec : ListId ':' Type { map (\x -> (ByV, x, $3)) $1 } 
  | 'VAR' ListId ':' Type { map (\x -> (ByVR, x, $4)) $2 }


ListId :: { [Id] }
ListId : Id { (:[]) $1 } 
  | Id ',' ListId { (:) $1 $3 }


RetTp :: { Type }
RetTp : ':' Type { $2 } 
  | {- empty -} { Tvoid }


Ini :: { [Stm] }
Ini : 'BEGIN' ListStm { $2 } 
  | {- empty -} { [] }


ListStm :: { [Stm] }
ListStm : Stm { (:[]) $1 } 
  | Stm ';' ListStm { (:) $1 $3 }


Stm :: { Stm }
Stm : Exp ':=' Exp
	{% let
			isLExp (ID _) = True
			isLExp (ARR _ _) = True
			isLExp (Una "^" x) = isLExp x
			isLExp _ = False	 
		in
			if isLExp $1 then return Assign $1 $3
			else fail "parser: rilevata una lexp mal formata"	}
  | Id Arg { Call $1 $2 }
  | 'EXIT' { Break }
  | 'RETURN' RetExp { Return $2 }
  | 'CONTINUE' { GoOn }
  | 'WHILE' Exp 'DO' ListStm 'END' { While $2 $4 }
  | 'REPEAT' ListStm 'UNTIL' Exp { Repeat $2 $4 }
  | 'LOOP' ListStm 'END' { Loop $2 }
  | 'CASE' Exp 'OF' ListBranch El 'END' { Case $2 $4 $5 }
  | 'IF' Exp 'THEN' ListStm ListElIf El 'END' { If (($2,$4):(reverse $5)) $6 }


RetExp :: { Maybe Exp }
RetExp : Exp { Just $1 } 
  | {- empty -} { Nothing }


Arg :: { [Exp] }
Arg : '(' ListExp ')' { $2 } 
  | {- empty -} { [] }


Branch :: { (Exp, [Stm]) }
Branch : Exp ':' ListStm { ($1, $3) } 


ListBranch :: { [(Exp, [Stm])] }
ListBranch : {- empty -} { [] } 
  | Branch { (:[]) $1 }
  | Branch '|' ListBranch { (:) $1 $3 }


ElIf :: { (Exp,[Stm]) }
ElIf : 'ELSEIF' Exp 'THEN' ListStm { ($2, $4) } 


El :: { Maybe [Stm] }
El : 'ELSE' ListStm { Just $2 } 
  | {- empty -} { Nothing }


ListElIf :: { [(Exp,[Stm])] }
ListElIf : {- empty -} { [] } 
  | ListElIf ElIf { flip (:) $1 $2 }


Type :: { Type }
Type : 'INTEGER' { Tint } 
  | 'BOOLEAN' { Tbool }
  | 'CHAR' { Tchar }
  | 'STRING' { Tstring }
  | 'ARRAY' Exp 'OF' Type { Tarray $2 $4 }
  | 'POINTER TO' Type { Tpointer $2 }
  | 'REAL' { Treal }


Exp :: { Exp }
Exp : Exp '=' Exp1 { Bin "=" $1 $3 } 
  | Exp '#' Exp1 { Bin "#" $1 $3 }
  | Exp '<' Exp1 { Bin "<" $1 $3 }
  | Exp '<=' Exp1 { Bin "<=" $1 $3 }
  | Exp '>' Exp1 { Bin ">" $1 $3 }
  | Exp '>=' Exp1 { Bin ">=" $1 $3 }
  | Exp1 { $1 }


Exp1 :: { Exp }
Exp1 : Exp1 '+' Exp2 { Bin "+" $1 $3 }
  | Exp1 '-' Exp2 { Bin "-" $1 $3 }
  | Exp1 'OR' Exp2 { Bin "OR" $1 $3 }
  | Exp2 { $1 }


Exp2 :: { Exp }
Exp2 : Exp2 'DIV' Exp3 { Bin "DIV" $1 $3 }
  | Exp2 'MOD' Exp3 { Bin "MOD" $1 $3 }
  | Exp2 '*' Exp3 { Bin "*" $1 $3 }
  | Exp2 '/' Exp3 { Bin "/" $1 $3 }
  | Exp2 '&' Exp3 { Bin "&" $1 $3 }
  | Exp3 { $1 }


Exp3 :: { Exp }
Exp3 : '~' Exp3 { Una "neg" $2 } 
  | Exp4 { $1 }


Exp4 :: { Exp }
Exp4 : Exp4 '^' { Una "deref" $1 }  
  | Exp5 { $1 }


Exp5 :: { Exp }
Exp5 : 'FALSE' { TRUE } 
  | 'TRUE' { FALSE }
  | Integer { INT $1 }
  | Double { REAL $1 }
  | Char { CHAR $1 }
  | String { STRING $1 }
  | Id { ID $1 }
  | Id '[' ListExp ']' { ARR $1 $3 }
  | Id '(' ListExp ')' { CALL $1 $3 }
  | '(' Exp ')' { $2 }


ListExp :: { [Exp] }
ListExp : {- empty -} { [] } 
  | Exp { (:[]) $1 }
  | Exp ',' ListExp { (:) $1 $3 }



{

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

